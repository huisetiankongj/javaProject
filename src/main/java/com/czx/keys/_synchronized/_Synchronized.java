package com.czx.keys._synchronized;

/**
 * synchronized是Java中的关键字，是java的内置锁，是一种同步锁。
 * 
 * java的内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，
 * 			    在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法
 * 			 java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，
 * 			  线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。
 * 
 * java的对象锁和类锁：
 * 			java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，
 * 			但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，
 * 			【类锁是用于类的静态方法或者一个类的class对象上的。
 * 			我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，
 * 			所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。】
 * 			但是有一点必须注意的是，其实【类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的】。
 * 
 * 
 * 1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
 * 2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
 * 3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
 * 4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。
 *
 * 总结：
 *  1、对象锁和类锁是两种不同的锁
 * 	2、无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；
 * 		如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
 * 	3、每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
 * 	4、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
 * @author admin
 *
 */
public class _Synchronized {

}
